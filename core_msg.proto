/*
 * This source file untangles all messages that can be returned
 * by ocgcore from its get_message() API call by listing what data
 * each message holds exactly (listing each value size in bytes)
 * while also providing a protobuf implementation of said message.
 *
 * If any message on the core would be modified/added, it must be specified here.
 */

syntax = "proto3";

import "core_data.proto";

package YGOpen.Core.Msg;

message Msg
{
	oneof msg
	{
		Retry retry = 16;
		Hint hint = 17;
		Waiting waiting = 18;
		Start start = 19;
		Win win = 20;
		UpdateData update_data = 21;
		UpdateCard update_card = 22;
		RequestDeck request_deck = 23;
		SelectBattleCmd select_battlecmd = 24;
		SelectIdleCmd select_idlecmd = 25;
		SelectEffectYn select_effectyn = 26;
		SelectYesNo select_yesno = 27;
		SelectOption select_option = 28;
		SelectCard select_card = 29;
		SelectChain select_chain = 30;
		SelectPlace select_place = 31;
		SelectPosition select_position = 32;
		SelectTribute select_tribute = 33;
		SortChain sort_chain = 34;
		SelectCounter select_counter = 35;
		SelectSum select_sum = 36;
		SelectDisfield select_disfield = 37;
		SortCard sort_card = 38;
		SelectUnselectCard select_unselect_card = 39;
		ConfirmDecktop confirm_decktop = 40;
		ConfirmCard confirm_card = 41;
		ShuffleDeck shuffle_deck = 42;
		ShuffleHand shuffle_hand = 43;
		RefreshDeck refresh_deck = 44;
		SwapGraveDeck swap_grave_deck = 45;
		ShuffleSetCard shuffle_set_card = 46;
		ReverseDeck reverse_deck = 47;
		DeckTop deck_top = 48;
		ShuffleExtra shuffle_extra = 49;
		NewTurn new_turn = 50;
		NewPhase new_phase = 51;
		ConfirmExtraTop confirm_extratop = 52;
		Move move = 53;
		PosChange pos_change = 54;
		Set set = 55;
		Swap swap = 56;
		FieldDisabled field_disabled = 57;
		Summoning summoning = 58;
		Summoned summoned = 59;
		SpSummoning spsummoning = 60;
		SpSummoned spsummoned = 61;
		FlipSummoning flipsummoning = 62;
		FlipSummoned flipsummoned = 63;
		Chaining chaining = 64;
		Chained chained = 65;
		ChainSolving chain_solving = 66;
		ChainSolved chain_solved = 67;
		ChainEnd chain_end = 68;
		ChainNegated chain_negated = 69;
		ChainDisabled chain_disabled = 70;
		CardSelected card_selected = 71;
		RandomSelected random_selected = 72;
		BecomeTarget become_target = 73;
		Draw draw = 74;
		Damage damage = 75;
		Recover recover = 76;
		Equip equip = 77;
		LpUpdate lpupdate = 78;
		Unequip unequip = 79;
	}
}

// number: 1 (MSG_RETRY)
// data: none
message Retry
{
}

// number: 2 (MSG_HINT)
// data:
// type [uint8]
// target_player [uint8]
// data [uint64]
// NOTE: on operations.cpp:2468,3382 write_buffer32 is used instead of 64. Check needed.
// TODO: depending on how hints are handled we should be able to use different messages for hint types
message Hint
{
	int32 type = 1;
	int32 player = 2;
	oneof data
	{
		int64 data64 = 3;
		int32 data32 = 4;
	}
}

// number: 3 (MSG_WAITING)
// data:
// TODO: missing on ocgcore
message Waiting
{
}

// number: 4 (MSG_START)
// data:
// TODO: missing on ocgcore
message Start
{
}

// number: 5 (MSG_WIN)
// data:
// win_player [uint8]
// win_reason [uint8]
message Win
{
	int32 player = 1;
	int32 reason = 2;
}

// number: 6 (MSG_UPDATE_DATA)
// data:
// TODO: missing on ocgcore
message UpdateData
{
}

// number: 7 (MSG_UPDATE_CARD)
// data:
// TODO: missing on ocgcore
message UpdateCard
{
}

// number: 8 (MSG_REQUEST_DECK)
// data:
// TODO: missing on ocgcore
message RequestDeck
{
}

// number: 10 (MSG_SELECT_BATTLECMD)
// data:
// playerid [uint8]
// select_chains.size() [uint8]
//	repeated code [uint32]
//	repeated controler [uint8]
//	repeated sequence [uint32]
//	repeated peffect->description [uint64]
// attackable_cards.size() [uint8]
//	repeated code [uint32]
//	repeated controler [uint8]
//	repeated sequence [uint32]
//	repeated pcard->direct_attackable [uint8]
// to_m2 [uint8]
// to_ep [uint8]
message SelectBattleCmd
{
	int32 player = 1;
	bool able_to_mp2 = 2;
	bool able_to_ep = 3;

	repeated Data.CardInfo cards_w_effect = 4;
	repeated Data.CardInfo cards_can_attack = 5;
}

// number: 11 (MSG_SELECT_IDLECMD)
// data:
// playerid [uint8]
// summonable_cards.size() [uint8]
//	repeated code [uint32]
//	repeated controler [uint8]
//	repeated location [uint8]
//	repeated sequence [uint32]
// spsummonable_cards.size() [uint8]
//	repeated code [uint32]
//	repeated controler [uint8]
//	repeated location [uint8]
//	repeated sequence [uint32]
// repositionable_cards.size() [uint8]
//	repeated code [uint32]
//	repeated controler [uint8]
//	repeated location [uint8]
//	repeated sequence [uint8] // NOTE: different size
// msetable_cards.size() [uint8]
//	repeated code [uint32]
//	repeated controler [uint8]
//	repeated location [uint8]
//	repeated sequence [uint32]
// ssetable_cards.size() [uint8]
//	repeated code [uint32]
//	repeated controler [uint8]
//	repeated location [uint8]
//	repeated sequence [uint32]
// select_chains.size() [uint8]
//	repeated code [uint32]
//	repeated controler [uint8]
//	repeated sequence [uint32]
//	repeated peffect->description [uint64]
// to_bp [uint8]
// to_ep [uint8]
// can_shuffle [uint8]
message SelectIdleCmd
{
	int32 player = 1;
	bool able_to_bp = 2;
	bool able_to_ep = 3;
	bool can_shuffle = 4;
	
	repeated Data.CardInfo cards_summonable = 5;
	repeated Data.CardInfo cards_spsummonable = 6;
	repeated Data.CardInfo cards_repositionable = 7;
	repeated Data.CardInfo cards_msetable = 8;
	repeated Data.CardInfo cards_ssetable = 9;
	repeated Data.CardInfo cards_w_effect = 10;
}

// number: 12 (MSG_SELECT_EFFECTYN)
// data:
// playerid [uint8]
// code [uint32]
// loc_info tmp_info = pcard->get_info_location(); [sizeof loc_info]
// description [uint64]
message SelectEffectYn
{
	int32 player = 1;
	Data.CardInfo card = 2;
}

// number: 13 (MSG_SELECT_YESNO)
// data:
// playerid [uint8]
// description [uint64]
message SelectYesNo
{
	int32 player = 1;
	int64 description = 2;
}

// number: 14 (MSG_SELECT_OPTION)
// data:
// playerid [uint8]
// core.select_options.size() [uint8]
//	repeated description [uint64]
message SelectOption
{
	int32 player = 1;
	repeated int64 descriptions = 2;
}

// number: 15 (MSG_SELECT_CARD)
// data:
// playerid [uint8]
// cancelable [uint8]
// min [uint8]
// max [uint8]
// core.select_cards.size() [uint32]
//	repeated code [uint32]
//	repeated loc_info tmp_info = pcard->get_info_location(); [sizeof loc_info]
message SelectCard
{
	int32 player = 1;
	bool can_cancel = 2;
	int32 min_selection = 3;
	int32 max_selection = 4;
	repeated Data.CardInfo cards_selectable = 5;
}

// number: 16 (MSG_SELECT_CHAIN)
// data:
// playerid [uint8]
// select_chains.size() [uint8]
// spe_count [uint8]
// forced [uint8]
// pduel->game_field->core.hint_timing[playerid] [uint32]
// pduel->game_field->core.hint_timing[1 - playerid] [uint32]
//	repeated EDESC [uint8]
//	repeated code [uint32]
//	repeated loc_info tmp_info = pcard->get_info_location(); [sizeof loc_info]
//	repeated description [uint64]
message SelectChain
{
	int32 player = 1;
	int32 spe_cout = 2; // TODO: needs investigation
	bool forced = 3; // TODO: needs investigation
	int32 hint_timing_this_player = 4; // TODO: needs investigation
	int32 hint_timing_other_player = 5; // TODO: needs investigation
	repeated Data.Chain chains = 6;
}

// number: 18 (MSG_SELECT_PLACE)
// data:
// playerid [uint8]
// count [uint8]
// flag [uint32]
message SelectPlace
{
	int32 player = 1;
	int32 count = 2;
	int32 flag = 3;
}

// number: 19 (MSG_SELECT_POSITION)
// data:
// playerid [uint8]
// code [uint32]
// positions [uint8]
message SelectPosition
{
	int32 player = 1;
	Data.CardInfo card = 2;
}

// number: 20 (MSG_SELECT_TRIBUTE)
// data:
// playerid [uint8]
// cancelable [uint8]
// min [uint8]
// max [uint8]
// core.select_cards.size() [uint32]
//	repeated code [uint32]
//	repeated current.controler [uint8]
//	repeated current.location [uint8]
//	repeated current.sequence [uint32]
//	repeated release_param [uint8]
message SelectTribute
{
	int32 player = 1;
	bool can_cancel = 2;
	int32 min_selection = 3;
	int32 max_selection = 4;
	repeated Data.CardInfo cards_tributable = 5;
}

// number: 21 (MSG_SORT_CHAIN)
// data:
// playerid [uint8]
// select_cards.size() [uint8]
//	repeated code [uint32]
//	repeated controler [uint8]
//	repeated location [uint32]
//	repeated sequence [uint32]
message SortChain
{
	int32 player = 1;
	Data.CardInfo cards_to_sort = 2;
}

// number: 22 (MSG_SELECT_COUNTER)
// data:
// playerid [uint8]
// countertype [uint16]
// count [uint16]
// core.select_cards.size() [uint8]
//	repeated code [uint32]
//	repeated controler [uint8]
//	repeated location [uint8]
//	repeated sequence [uint8]
//	repeated get_counter(countertype) [uint16]
message SelectCounter
{
	int32 player = 1;
	Data.Counter counter = 2;
	repeated Data.CardInfo cards_selectable = 3;
}

// number: 23 (MSG_SELECT_SUM)
// data:
// playerid [uint8]
// acc & 0xffff [uint32]
// min [uint8]
// max [uint8]
// core.must_select_cards.size() [uint8]
//	repeated code [uint32]
//	repeated controler [uint8]
//	repeated location [uint8]
//	repeated sequence [uint32]
//	repeated sum_param [uint32]
// core.select_cards.size() [uint8]
//	repeated code [uint32]
//	repeated controler [uint8]
//	repeated location [uint8]
//	repeated sequence [uint32]
//	repeated sum_param [uint32]
message SelectSum
{
	int32 player = 1;
	Data.Counter counter = 2;
	repeated Data.CardInfo cards_must_select = 3;
	repeated Data.CardInfo cards_selectable = 4;
}

// number: 24 (MSG_SELECT_DISFIELD) NOTE: same as MSG_SELECT_PLACE
// data:
// playerid [uint8]
// count [uint8]
// flag [uint32]
message SelectDisfield
{
	int32 player = 1;
	int32 count = 2;
	int32 flag = 3;
}

// number: 25 (MSG_SORT_CARD) NOTE: same as MSG_SORT_CHAIN
// data:
// playerid [uint8]
// select_cards.size() [uint8]
//	repeated code [uint32]
//	repeated controler [uint8]
//	repeated location [uint32]
//	repeated sequence [uint32]
message SortCard
{
	int32 player = 1;
	Data.CardInfo cards_to_sort = 2;
}

// number: 26 (MSG_SELECT_UNSELECT_CARD)
// data:
// playerid [uint8]
// buttonok [uint8]
// cancelable [uint8]
// min [uint8]
// max [uint8]
// core.select_cards.size() [uint32]
//	repeated code [uint32]
//	repeated loc_info tmp_info = pcard->get_info_location(); [sizeof loc_info]
// core.unselect_cards.size() [uint32]
//	repeated code [uint32]
//	repeated loc_info tmp_info = pcard->get_info_location(); [sizeof loc_info]
message SelectUnselectCard
{
	int32 player = 1;
	bool buttonok = 2; // TODO: needs investigation
	bool can_cancel = 3;
	int32 min_selection = 4;
	int32 max_selection = 5;
	repeated Data.CardInfo cards_selectable = 6;
	repeated Data.CardInfo cards_unselectable = 7;
}

// number: 30 (MSG_CONFIRM_DECKTOP)
// data:
// playerid [uint8]
// count [uint8]
//	repeated code [uint32]
//	repeated controler [uint8]
//	repeated location [uint8]
//	repeated sequence [uint8]
message ConfirmDecktop
{
	int32 player = 1;
	repeated Data.CardInfo cards = 2;
}

// number: 31 (MSG_CONFIRM_CARDS) NOTE: same as MSG_CONFIRM_DECKTOP
// data:
// playerid [uint8]
// count [uint8]
//	repeated code [uint32]
//	repeated controler [uint8]
//	repeated location [uint8]
//	repeated sequence [uint32]
// NOTE: on operations.cpp:431 write_buffer8 is used instead of 32. Check needed.
message ConfirmCard
{
	int32 player = 1;
	repeated Data.CardInfo cards = 2;
}

// number: 32 (MSG_SHUFFLE_DECK)
// data:
// playerid [uint8]
message ShuffleDeck
{
	int32 player = 1;
}

// number: 33 (MSG_SHUFFLE_HAND)
// data:
// playerid [uint8]
// svector.size() [uint8]
//	repeated code [uint32]
message ShuffleHand
{
	int32 player = 1;
	repeated Data.CardInfo codes = 2; // NOTE: maybe we can use just a int32 instead
}

// number: 34 (MSG_REFRESH_DECK)
// data:
// TODO: missing on ocgcore
message RefreshDeck
{
}

// number: 35 (MSG_SWAP_GRAVE_DECK)
// data:
// playerid [uint8]
message SwapGraveDeck
{
	int32 player = 1;
}

// number: 36 (MSG_SHUFFLE_SET_CARD)
// data:
// location [uint8]
// count [uint8]
// repeated loc_info previous [sizeof loc_info]
// repeated loc_info current [sizeof loc_info]
message ShuffleSetCard
{
	int32 location = 1;
	// NOTE: number of messages in each repeated field must match
	repeated Data.CardInfo cards_previous = 2;
	repeated Data.CardInfo cards_current = 3; // NOTE: might be empty
}

// number: 37 (MSG_REVERSE_DECK)
// data: none
// NOTE: actual information sent by MSG_DECK_TOP
message ReverseDeck
{
}

// number: 38 (MSG_DECK_TOP)
// data:
// playerid [uint8]
// sequence [uint8]
// code [uint32] // NOTE: POS_FACEUP_DEFENSE is OR'd on last bit
message DeckTop
{
	int32 player = 1;
	Data.CardInfo card = 2;
}

// number: 39 (MSG_SHUFFLE_EXTRA) // NOTE: same as MSG_SHUFFLE_HAND
// data:
// playerid [uint8]
// svector.size() [uint8]
//	repeated code [uint32]
message ShuffleExtra
{
	int32 player = 1;
	repeated Data.CardInfo codes = 2; // NOTE: maybe we can use just a int32 instead
}

// number: 40 (MSG_NEW_TURN)
// data:
// turn_player [uint8]
message NewTurn
{
	int32 player = 1;
}

// number: 41 (MSG_NEW_PHASE)
// data:
// phase [uint16]
message NewPhase
{
	int32 phase = 1;
}

// number: 42 (MSG_CONFIRM_EXTRATOP)
// data:
// playerid [uint8]
// count [uint8]
//	repeated code [uint32]
//	repeated controler [uint8]
//	repeated location [uint8]
//	repeated sequence [uint8]
message ConfirmExtraTop
{
	int32 player = 1;
	repeated Data.CardInfo cards = 2;
}

// number: 50 (MSG_MOVE)
// data:
// code [uint32]
// loc_info previous [sizeof loc_info]
// loc_info current [sizeof loc_info]
// reason [uint32]
message Move
{
	int32 player = 1;
	int32 reason = 2;
	repeated Data.CardInfo previous = 3;
	repeated Data.CardInfo current = 4;
}

// number: 53 (MSG_POS_CHANGE)
// data:
// code [uint32]
// current.controler [uint8]
// current.location [uint8]
// current.sequence [uint8]
// previous.position [uint8]
// current.position [uint8]
message PosChange
{
	repeated Data.CardInfo previous = 1;
	repeated Data.CardInfo current = 2;
}

// number: 54 (MSG_SET)
// data:
// code [uint32]
// loc_info current [sizeof loc_info]
message Set
{
	Data.CardInfo card = 1;
}

// number: 55 (MSG_SWAP)
// data:
// code1 [uint32]
// loc_info current [sizeof loc_info]
// code2 [uint32]
// loc_info current [sizeof loc_info]
message Swap
{
	Data.CardInfo card1 = 1;
	Data.CardInfo card2 = 2;
}

// number: 56 (MSG_FIELD_DISABLED)
// data:
// dis [uint32]
message FieldDisabled
{
	int32 dis = 1; // TODO: needs investigation
}

// number: 60 (MSG_SUMMONING) // NOTE: same as MSG_SET
// data:
// code [uint32]
// loc_info current [sizeof loc_info]
message Summoning
{
	Data.CardInfo card = 1;
}

// number: 61 (MSG_SUMMONED)
// data: none
message Summoned
{
}

// number: 62 (MSG_SPSUMMONING) // NOTE: same as MSG_SUMMONING
// data:
// code [uint32]
// loc_info current [sizeof loc_info]
message SpSummoning
{
	Data.CardInfo card = 1;
}

// number: 63 (MSG_SPSUMMONED) // NOTE: same as MSG_SUMMONED
// data: none
message SpSummoned
{
}

// number: 64 (MSG_FLIPSUMMONING) // NOTE: same as MSG_SUMMONING
// data:
// code [uint32]
// loc_info current [sizeof loc_info]
message FlipSummoning
{
	Data.CardInfo card = 1;
}

// number: 65 (MSG_FLIPSUMMONED) // NOTE: same as MSG_SUMMONED
// data: none
message FlipSummoned
{
}

// number: 70 (MSG_CHAINING)
// data:
// code [uint32]
// loc_info location [sizeof loc_info]
// triggering_controler [uint8]
// triggering_location [uint8]
// triggering_sequence [uint8]
// description [uint64] // NOTE: effect description
// current_chain.size() + 1 [uint8]
message Chaining
{
	Data.CardInfo location = 1;
	Data.CardInfo triggering_location = 2;
	int64 description = 3;
	int32 chain_size = 4;
}

// number: 71 (MSG_CHAINED)
// data:
// chain_count [uint8]
message Chained
{
	int32 chain_count = 1;
}

// number: 72 (MSG_CHAIN_SOLVING) // NOTE: same as MSG_CHAINED
// data:
// chain_count [uint8]
message ChainSolving
{
	int32 chain_count = 1;
}

// number: 73 (MSG_CHAIN_SOLVED) // NOTE: same as MSG_CHAINED
// data:
// chain_count [uint8]
message ChainSolved
{
	int32 chain_count = 1;
}

// number: 74 (MSG_CHAIN_END)
// data: none
message ChainEnd
{
}

// number: 75 (MSG_CHAIN_NEGATED) // NOTE: same as MSG_CHAINED
// data:
// chain_count [uint8]
message ChainNegated
{
	int32 chain_count = 1;
}

// number: 76 (MSG_CHAIN_DISABLED) // NOTE: same as MSG_CHAINED
// data:
// chain_count [uint8]
message ChainDisabled
{
	int32 chain_count = 1;
}

// number: 80 (MSG_CARD_SELECTED)
// data:
// TODO: missing on ocgcore
message CardSelected
{
}

// number: 81 (MSG_RANDOM_SELECTED)
// data:
// it->arg1 [uint8]
// count [uint8]
//	repeated loc_info cards [sizeof loc_info]
message RandomSelected
{
	int32 arg1 = 1;
	repeated Data.CardInfo cards = 2;
}

// number: 83 (MSG_BECOME_TARGET)
// data:
// 1? [uint8] // TODO: needs investigation
// loc_info card [sizeof loc_info]
message BecomeTarget
{
	int32 arg1 = 1;
	repeated Data.CardInfo card = 2;
}

// number: 90 (MSG_DRAW)
// data:
// playerid [uint8]
// drawed_count [uint8]
//	repeated code [uint32] // NOTE: has POS_FACEUP OR'd in the last bit
message Draw
{
	int32 player = 1;
	repeated Data.CardInfo cards = 2;
}

// number: 91 (MSG_DAMAGE)
// data:
// playerid [uint8]
// amount [uint32]
message Damage
{
	int32 player = 1;
	int32 amount = 2;
}

// number: 92 (MSG_RECOVER) // NOTE: same as MSG_DAMAGE
// data:
// playerid [uint8]
// amount [uint32]
message Recover
{
	int32 player = 1;
	int32 amount = 2;
}

// number: 93 (MSG_EQUIP)
// data:
// loc_info card [sizeof loc_info]
// loc_info target [sizeof loc_info]
message Equip
{
	Data.CardInfo card = 1;
	Data.CardInfo target = 2;
}

// number: 94 (MSG_LPUPDATE) // NOTE: same as MSG_DAMAGE
// data:
// playerid [uint8]
// amount [uint32]
message LpUpdate
{
	int32 player = 1;
	int32 number = 2;
}

// number: 95 (MSG_UNEQUIP)
// data:
// TODO: missing on ocgcore
message Unequip
{
}
