/*
 * This source file untangles all messages that can be returned
 * by ocgcore from its get_message() API call by listing what data
 * each message holds exactly (listing each value size in bytes)
 * while also providing a protobuf implementation of said message.
 *
 * If any message on the core would be modified/added, it must be specified here.
 */

syntax = "proto3";

import "core_data.proto";

package YGOpen.Core.Msg;

message Msg
{
	oneof msg
	{
		Retry retry = 16;
		Hint hint = 17;
		Waiting waiting = 18;
		Start start = 19;
		Win win = 20;
		UpdateData update_data = 21;
		UpdateCard update_card = 22;
		RequestDeck request_deck = 23;
		SelectBattleCmd select_battlecmd = 24;
		SelectIdleCmd select_idlecmd = 25;
		SelectEffectYn select_effectyn = 26;
		SelectYesNo select_yesno = 27;
		SelectOption select_option = 28;
		SelectCard select_card = 29;
		SelectChain select_chain = 30;
		SelectPlace select_place = 31;
		SelectPosition select_position = 32;
		
		NewTurn new_turn = 99;
	}
}

// number: 1 (MSG_RETRY)
// data: none
message Retry
{
}

// number: 2 (MSG_HINT)
// data:
// type [uint8]
// target_player [uint8]
// data [uint64]
// NOTE: on operations.cpp:2468,3382 write_buffer32 is used instead of 64. Check needed.
// TODO: depending on how hints are handled we should be able to use different messages for hint types
message Hint
{
	int32 type = 1;
	int32 player = 2;
	oneof data
	{
		int64 data64 = 3;
		int32 data32 = 4;
	}
}

// number: 3 (MSG_WAITING)
// data:
// TODO: missing on ocgcore
message Waiting
{
}

// number: 4 (MSG_START)
// data:
// TODO: missing on ocgcore
message Start
{
}

// number: 5 (MSG_WIN)
// data:
// win_player [uint8]
// win_reason [uint8]
message Win
{
	int32 player = 1;
	int32 reason = 2;
}

// number: 6 (MSG_UPDATE_DATA)
// data:
// TODO: missing on ocgcore
message UpdateData
{
}

// number: 7 (MSG_UPDATE_CARD)
// data:
// TODO: missing on ocgcore
message UpdateCard
{
}

// number: 8 (MSG_REQUEST_DECK)
// data:
// TODO: missing on ocgcore
message RequestDeck
{
}

// number: 10 (MSG_SELECT_BATTLECMD)
// data:
// playerid [uint8]
// select_chains.size() [uint8]
//	repeated code [uint32]
//	repeated controler [uint8]
//	repeated sequence [uint32]
//	repeated peffect->description [uint64]
// attackable_cards.size() [uint8]
//	repeated code [uint32]
//	repeated controler [uint8]
//	repeated sequence [uint32]
//	repeated pcard->direct_attackable [uint8]
// to_m2 [uint8]
// to_ep [uint8]
message SelectBattleCmd
{
	int32 player = 1;
	bool able_to_mp2 = 2;
	bool able_to_ep = 3;

	repeated Data.CardWithEffect cards_w_effect = 4;
	repeated Data.CardCanAttack cards_can_attack = 5;
}

// number: 11 (MSG_SELECT_IDLECMD)
// data:
// playerid [uint8]
// summonable_cards.size() [uint8]
//	repeated code [uint32]
//	repeated controler [uint8]
//	repeated location [uint8]
//	repeated sequence [uint32]
// spsummonable_cards.size() [uint8]
//	repeated code [uint32]
//	repeated controler [uint8]
//	repeated location [uint8]
//	repeated sequence [uint32]
// repositionable_cards.size() [uint8]
//	repeated code [uint32]
//	repeated controler [uint8]
//	repeated location [uint8]
//	repeated sequence [uint8] // NOTE: different size
// msetable_cards.size() [uint8]
//	repeated code [uint32]
//	repeated controler [uint8]
//	repeated location [uint8]
//	repeated sequence [uint32]
// ssetable_cards.size() [uint8]
//	repeated code [uint32]
//	repeated controler [uint8]
//	repeated location [uint8]
//	repeated sequence [uint32]
// select_chains.size() [uint8]
//	repeated code [uint32]
//	repeated controler [uint8]
//	repeated sequence [uint32]
//	repeated peffect->description [uint64]
// to_bp [uint8]
// to_ep [uint8]
// can_shuffle [uint8]
message SelectIdleCmd
{
	int32 player = 1;
	bool able_to_bp = 2;
	bool able_to_ep = 3;
	bool can_shuffle = 4;
	
	repeated Data.CardInfo cards_summonable = 5;
	repeated Data.CardInfo cards_spsummonable = 6;
	repeated Data.CardInfo cards_repositionable = 7;
	repeated Data.CardInfo cards_msetable = 8;
	repeated Data.CardInfo cards_ssetable = 9;
	repeated Data.CardWithEffect cards_w_effect = 10;
}

// number: 12 (MSG_SELECT_EFFECTYN)
// data:
// playerid [uint8]
// code [uint32]
// loc_info tmp_info = pcard->get_info_location(); [sizeof loc_info]
// description [uint64]
message SelectEffectYn
{
	int32 player = 1;
	Data.CardWithEffect card = 2;
}

// number: 13 (MSG_SELECT_YESNO)
// data:
// playerid [uint8]
// description [uint64]
message SelectYesNo
{
	int32 player = 1;
	int64 description = 2;
}

// number: 14 (MSG_SELECT_OPTION)
// data:
// playerid [uint8]
// core.select_options.size() [uint8]
//	repeated description [uint64]
message SelectOption
{
	int32 player = 1;
	repeated int64 descriptions = 2;
}

// number: 15 (MSG_SELECT_CARD)
// data:
// playerid [uint8]
// cancelable [uint8]
// min [uint8]
// max [uint8]
// core.select_cards.size() [uint32]
//	repeated code [uint32]
//	repeated loc_info tmp_info = pcard->get_info_location(); [sizeof loc_info]
message SelectCard
{
	int32 player = 1;
	bool can_cancel = 2;
	int32 min_selection = 3;
	int32 max_selection = 4;
	repeated Data.CardInfo cards_selectable = 5;
}

// number: 16 (MSG_SELECT_CHAIN)
// data:
// playerid [uint8]
// select_chains.size() [uint8]
// spe_count [uint8]
// forced [uint8]
// pduel->game_field->core.hint_timing[playerid] [uint32]
// pduel->game_field->core.hint_timing[1 - playerid] [uint32]
//	repeated EDESC [uint8]
//	repeated code [uint32]
//	repeated loc_info tmp_info = pcard->get_info_location(); [sizeof loc_info]
//	repeated description [uint64]
message SelectChain
{
	int32 player = 1;
	int32 spe_cout = 2; // TODO: needs investigation
	bool forced = 3; // TODO: needs investigation
	int32 hint_timing_this_player = 4; // TODO: needs investigation
	int32 hint_timing_other_player = 5; // TODO: needs investigation
	repeated Data.Chain chains = 6;
}

// number: 18 (MSG_SELECT_PLACE)
// data:
// playerid [uint8]
// count [uint8]
// flag [uint32]
message SelectPlace
{
	int32 player = 1;
	int32 count = 2;
	int32 flag = 3;
}

// number: 19 (MSG_SELECT_POSITION)
// data:
// playerid [uint8]
// code [uint32]
// positions [uint8]
message SelectPosition
{
	int32 player = 1;
	Data.CardInfo card = 2;
}

// number: 40 (MSG_NEW_TURN)
// data:
// turn_player [uint8]
message NewTurn
{
	int32 player = 1;
}
