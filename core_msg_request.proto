syntax = "proto3";

import "core_data.proto";

package YGOpen.Core.Msg;

// Encapsulates:
// MSG_SELECT_BATTLECMD
// MSG_SELECT_IDLECMD
message SelectCmd
{
	enum CmdType
	{
		COMMAND_BATTLE = 0;
		COMMAND_IDLE = 1;
	}

	CmdType type = 1;

	// Can the player go to these phases?
	//bool able_to_dp = 2;  // Draw Phase // NOTE: UNUSED
	//bool able_to_sp = 3;  // Standby Phase // NOTE: UNUSED
	//bool able_to_mp1 = 4; // Main Phase 1 // NOTE: UNUSED
	bool able_to_bp = 5;  // Battle Phase
	bool able_to_mp2 = 6; // Main Phase 2
	bool able_to_ep = 7;  // End Phase

	bool can_shuffle = 8; // Can the player shuffle its hand

	// Usable cards
	repeated Data.CardInfo cards_w_effect = 9; // Cards anywhere in the field that can activate a ignition effect
	repeated Data.CardInfo cards_can_attack = 10; // Cards that can declare an attack
	repeated Data.CardInfo cards_summonable = 11; // Cards that can be either Normal or Tribute summoned
	repeated Data.CardInfo cards_spsummonable = 12; // Cards that can be Special summoned (inherent)
	repeated Data.CardInfo cards_repositionable = 13; // Cards that can change Battle Position
	repeated Data.CardInfo cards_msetable = 14; // Cards that can be set on a Monster Zone
	repeated Data.CardInfo cards_ssetable = 15; // Cards that can be set on a Spell/Trap Zone
}

// Encapsulates:
// MSG_SELECT_EFFECTYN
// MSG_SELECT_YESNO
message SelectYesNo
{
	oneof SelectYesNo
	{
		// Asks for a effect by a specific card on a specific zone
		// Example: From [Monster Zone] activate "Elemental HERO Stratos"?
		Data.CardInfo card = 1;
		// Asks for a effect
		// Example: Banish "Return of the Dragon Lords" from the Graveyard instead?
		Data.EffectDesc effect = 2;
	}
}

// Encapsulates:
// MSG_SELECT_OPTION
message SelectOption
{
	// List of effects description the player can choose
	repeated Data.EffectDesc effects = 3;
}

// Encapsulates:
// MSG_SELECT_CARD
// MSG_SELECT_TRIBUTE
// MSG_SELECT_SUM
// MSG_SELECT_UNSELECT_CARD
// MSG_SELECT_COUNTER
message SelectCards
{
	enum SelectionType
	{
		SELECTION_EFFECT = 0;
		SELECTION_TRIBUTE = 1;
		SELECTION_SUM = 2;
		SELECTION_SELECT_UNSELECT = 3;
		SELECTION_COUNTER = 4;
	}
	
	SelectionType type = 1;
	
	// Can the player cancel the selection completely?
	bool can_cancel = 2;
	// Can the player finish the selection as is?
	bool can_accept = 3;
	// Minimum cards to select
	int32 min = 4;
	// Maximum cards to select
	int32 max = 5;
	
	// Sum needed to satisfy selection
	// FIXME: explain this value properly
	int32 sum = 6;
	
	// Counter type and number of counters the player
	// can distribute among the selectable cards
	Data.Counter counter = 7;
	
	// Cards that must be selected
	repeated Data.CardInfo cards_must_select = 10;
	
	// Cards that can be selected
	repeated Data.CardInfo cards_selectable = 11;
	
	// Cards that are selected and can be unselected
	repeated Data.CardInfo cards_unselectable = 12;
}

// Encapsulates:
// MSG_SORT_CARD
// MSG_SORT_CHAIN
message SortCards
{
	// Cards that you must place in the order you want them to activate
	repeated Data.CardInfo cards_to_sort = 1;
}

// Encapsulates:
// MSG_SELECT_PLACE
// MSG_SELECT_DISFIELD
message SelectPlaces
{
	//Reason reason = 1;
	
	// Minimum places to select
	int32 min = 2;
	
	// Places to select from
	repeated Data.Place places = 3;
}

// Encapsulates:
// MSG_SELECT_POSITION
message SelectPosition
{
	// Has code of the card
	// and available positions to choose from AND'd on position variable
	Data.CardInfo card = 1;
}

// Encapsulates:
// MSG_ANNOUNCE_CARD
// MSG_ANNOUNCE_CARD_FILTER
message DeclareCard
{
	enum DeclareCardOpcodes
	{
		// Values taken from ocgcore/common.h
		OPCODE_INVALID     = 0x00000000;
		OPCODE_ADD         = 0x40000000;
		OPCODE_SUB         = 0x40000001;
		OPCODE_MUL         = 0x40000002;
		OPCODE_DIV         = 0x40000003;
		OPCODE_AND         = 0x40000004;
		OPCODE_OR          = 0x40000005;
		OPCODE_NEG         = 0x40000006;
		OPCODE_NOT         = 0x40000007;
		OPCODE_ISCODE      = 0x40000100;
		OPCODE_ISSETCARD   = 0x40000101;
		OPCODE_ISTYPE      = 0x40000102;
		OPCODE_ISRACE      = 0x40000103;
		OPCODE_ISATTRIBUTE = 0x40000104;
	}
	
	oneof DeclareCard
	{
		// Type(s) of cards to declare from:
		// Monster, Trap or Spell
		int32 types = 1;
		
		// Use Reverse Polish Notation to create a list
		// of operations to determine (client side) the card filter
		DeclareCardOpcodes opcodes = 2;
	}
}

// Encapsulates:
// MSG_ANNOUNCE_RACE
// MSG_ANNOUNCE_ATTRIB
// MSG_ANNOUNCE_NUMBER
message DeclareMisc
{
	enum DeclareType
	{
		DECLARE_RACE = 0;
		DECLARE_ATTRIBUTE = 1;
		DECLARE_NUMBER = 2;
	}
	
	DeclareType type = 1;

	// Number of Attributes or Races you can choose
	// If type == DECLARE_NUMBER then this is the max value you can select
	// FIXME: probably use a min/max variables intead
	int32 count = 2;
	
	// Attributes or Races you can choose from (they are OR'd together)
	int32 available = 3;
}

// Encapsulates:
// MSG_SELECT_CHAIN
message SelectToChain
{
	// holds a chain type along with a card (and its effect)
	message ChainableCard
	{
		// NOTE: possible values
		// #define EDESC_OPERATION 1
		// #define EDESC_RESET     2
		// or 0
		// Tells the client if the effect is bound or not
		// to the card location
		// FIXME: use a bool instead?
		int32 effect_desc_type = 1;
		
		// The card must hold a effect description
		Data.CardInfo card = 2;
	}

	// Is any effect mandatory
	bool forced = 1;
	
	//int32 spe_count = 2; // NOTE: might not be required

	// Cards that can be chained or resolved
	repeated ChainableCard cards_w_effect = 3;
}

